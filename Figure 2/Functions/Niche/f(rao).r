###################################################################################################################################
#	This function is adapted from:
#			deBello et al., 2010. The partitionning of diversity: showing Theseus a way out the labyrinth. 
#				Journal of vegetation science 21: 992–1000, 2010. DOI: 10.1111/j.1654-1103.2010.01195.x
#	------------------------------------------------------------------------------
# 	The Rao function computes alpha, gamma and beta-components for taxonomic and phylogenetic diversity with the Rao index          
# 	The script integrates two functions: -	"Qdecomp", by Villeger & Mouillot (J Ecol, 2008) modify by Wilfried Thuiller
#										 -	"disc", by S. Pavoine, in the package ade4
# 	For a regional assemblage of C local communities gamma = mean(alpha) + beta, where:
#  -	"gamma" is the diversity of the regional pool
#  -	"alpha" are the diversities of the local communities
#  -	"beta" is the turnover between local communities
#  -	diversity is estimated with the Rao quadratic entropy index (Rao 1982)
#	------------------------------------------------------------------------------
#	INPUTS: 
#	------------------------------------------------------------------------------           
#	- "phylo.distance": can be a phylogenetic distances matrix or a phylogenetic tree ("phylo" object) depicting the dissimilarity between Microbial Diversity Units
#	- "funct.distance": a functional distance matrix depicting the dissimilarity between Microbial Diversity Units (typically a "dist" object as generated by "vegdist" function)
#	- "community.composition":  a matrix (MDU x C) with the presence/absence or abundances of the MDUs (Microbial Diversity Units; in rows) in the C local communities (in columns)           
#	- "local.community.ab.weight": defining if the correction by Villeger & Mouillot (J Ecol, 2008) is applied or not. If local.community.ab.weight=TRUE, local communities are weighted by their abundances
#  - "outputlike" : the way the output will look like, it can be a "list" or as default "tables"
#	------------------------------------------------------------------------------ 
#	OUTPUTS:  
#	------------------------------------------------------------------------------   
#	If you choose the "list" output (outpulike= "list")the results are organized in two lists: Rao.partition, which is calculated using only the community composition and Rao.partition.Phylogeny or Rao.partition.Functional which are calculated using the "phylo.distance" or the "funct.distance" objects. Each one of these list contains the following elements:
#	----------------------------------------------------------------------------------
#==>	Beta and gamma diversities calculated for the whole data set
#	- "$Richness.per.community"(number of MDU per sample)
#	- "$Microbial.Units.relative.abundance" (MDU relative abundances per plot)
#	- "$Global.relative.abundances" (species regional relative abundance)
#	- "$Local.community.weight" (weigthing factor),                               
#	- "$Q.MeanAlpha" 	(mean aplpha diversity, for taxonomic diversity the Simpson index is calculated)   
#	- "$Q.Alpha" 		(alpha diversity, for each sample, for taxonomic diversity the Simpson index is calculated)       
#	- "$Q.Gamma" 		(gamma diversity, for taxonomic diversity the Simpson index is calculated)                     
#	- "$Q.Beta" 		(Gamma-Mean_Alpha)                                          
#	- "$Q.Beta.st" 		(Beta_add*100/Gamma)  
#                                        
#==>	Beta and gamma diversities calculated for each pair of samples ("Pairwise_samples")
#	- "$Pairwise.community$Q.Alpha" 	(mean alpha for each pair of samples)   
#	- "$Pairwise.community$Q.Gamma" 	(gamma for each pair of samples)
#	- "$Pairwise.community$Q.Beta" 		(beta for each pair of samples as Gamma-Mean_Alpha)  
#	- "$Pairwise.community$Q.Beta.st" 	(beta for each pair of samples as Beta_add*100/Gamma)
#
#	If you choose the "tables" output the results are organised in 6 different tables:
#	----------------------------------------------------------------------------------
#	1. "$Microbial.Units.relative.abundances" 
#		contains the relative abundances of each MDU within each communities.The "Gbl.rel.ab" column contains the MDU relative abundance across all communities
#	2. "$Local.diversity" 
#		contains informations about the local communities diversity: their MDU richness, their weight which depends on their local abundances, their local alpha diversity values for taxonomic (TD) and phylogenetic (PD) or functional (FD) diversity facet
#	3. "$Richness.partition" 
#		contains estimated of the components of diversity partition using only richness of communities: "Gamma", "MeanAlpha",  "Beta", "Beta.st"
#	4. "$Rao.diversity.partition" 
#		contains estimated values of the components of diversity partition of Rao's quadratic entropy: "Q.Gamma", "Q.MeanAlpha",  "Q.Beta", "Q.Beta.st" 
#	5. "$Pairwise.partition" 
#		the same as "Div.part" but for couples of communities
#	6. "$Pairwise.partition.Phylogeny" or  "$Pairwise.partition.Functional"
#		the same as "Div.part" but for couples of communities and including phylogenetic or functional information
#####################################################################################################################################
# version 20130420
#####################################################################################################################################

Rao<-function(community.composition, phylo.distance= NULL,funct.distance= NULL ,local.community.ab.weight= FALSE , outputlike = "tables"){

library(ade4)
library(ape)
##########################################################################
#	--------------------------------------------------------------------- #
#	function Qdecomp by Villeger & Mouillot (J Ecol, 2008) 				  #
#		modify by Wilfried Thuiller								          #	
#	--------------------------------------------------------------------- #
##########################################################################
Qdecomp = function(functdist,abundances, w=TRUE) {

		# number and names of local communities
		c<-dim(abundances)[1] ; namescomm<-row.names(abundances)
		abundances<-as.matrix(abundances)

		# if necessary, transformation of functdist into matrix object
		if (is.matrix(functdist)==F) functdist<-as.matrix(functdist)
		# checking 'abundances' and 'functdist' dimensions
		if (dim(functdist)[1]!=dim(functdist)[2])  stop("error : 'functdist' has different number of rows and columns")
		if (dim(abundances)[2]!=dim(functdist)[1]) stop("error : different number of species in 'functdist' and 'abundances' ")

		# checking NA absence in 'functdist'
		if (length(which(is.na(functdist)==T))!=0)  stop("error : NA in 'functdist'")

		# replacement of NA by 0 in abundances
		if (is.na(sum(abundances))==T)  {
		for (i in 1:dim(abundances)[1])
		for (j in 1:dim(abundances)[2] )
		{ if(is.na(abundances[i,j])==T) abundances[i,j]<- 0 } # end of i j
		} # end of if

		#  species richness and total abundances in local communities
		abloc<-apply(abundances,1,sum)
		nbsploc<-apply(abundances,1,function(x) {length(which(x>0))} )

		# relative abundances inside each local community
		locabrel<-abundances/abloc

		# alpha diversity
		Qalpha=apply(locabrel, 1, function(x) t(x) %*%  functdist %*% x)
		#Wc
		Wc = abloc/sum(abloc)

		#	Villeger's correction
		if(w==T) {		# abundance-weighted mean alpha
			mQalpha<-as.numeric(Qalpha%*%abloc/sum(abloc) )
			totabrel<-apply(abundances,2,sum)/sum(abundances) 
			Qalpha = Qalpha*Wc
		}else {			# Rao's original definition: mean of Pi
			mQalpha<-mean(Qalpha)
			totabrel<-apply(locabrel,2,mean)  
			}

		# gamma diversity
		Qgamma<-( totabrel %*% functdist %*% totabrel ) [1]
		# beta diversity
		Qbeta<-as.numeric( Qgamma-mQalpha )
		# standardized beta diversity
		Qbetastd<-as.numeric(Qbeta/Qgamma )

		# list of results
		resQ<-list(Richness_per_plot=nbsploc, Relative_abundance= locabrel, Pi=totabrel, Wc=Wc, Species_abundance_per_plot=abloc, Alpha=Qalpha, Mean_alpha=mQalpha, Gamma=Qgamma, Beta=Qbeta, Standardize_Beta =Qbetastd )

return(resQ)
} # end of function Qdecomp

######################################################################
#	----------------------------------------------------------------- #
#		      function disc originally from S. Pavoine		          #
#	----------------------------------------------------------------- #
###################################################################### 
disc = function (samples, dis = NULL, structures = NULL, Jost = F)
{
    if (!inherits(samples, "data.frame"))		 			stop("Non convenient samples")
    if (any(samples < 0))				       				stop("Negative value in samples")
    if (any(apply(samples, 2, sum) < 1e-16))   			stop("Empty samples")
    if (!is.null(dis)) {
        if (!inherits(dis, "dist"))         				stop("Object of class 'dist' expected for distance")
        dis <- as.matrix(dis)
        if (nrow(samples) != nrow(dis))	     			stop("Non convenient samples")
    }
	if (!is.null(structures)) {
        if (!inherits(structures, "data.frame"))		stop("Non convenient structures")
        m <- match(apply(structures, 2, function(x) length(x)),
            ncol(samples), 0)
        if (length(m[m == 1]) != ncol(structures))	 	stop("Non convenient structures")
        m <- match(tapply(1:ncol(structures), as.factor(1:ncol(structures)),
            function(x) is.factor(structures[, x])), TRUE, 0)
        if (length(m[m == 1]) != ncol(structures))    stop("Non convenient structures")
    }
#	-------------------------------------------------- #
#					function structutil				   #
#	-------------------------------------------------- #
Structutil <- function(dp2, Np, unit, Jost) {
        if (!is.null(unit)) {
            modunit <- model.matrix(~-1 + unit)
            sumcol <- apply(Np, 2, sum)
            Ng <- modunit * sumcol
            lesnoms <- levels(unit)
        }else{
            Ng <- as.matrix(Np)
            lesnoms <- colnames(Np)
        }
        sumcol <- apply(Ng, 2, sum)
        Lg <- t(t(Ng)/sumcol)
        colnames(Lg) <- lesnoms
        Pg <- as.matrix(apply(Ng, 2, sum)/nbhaplotypes)
        rownames(Pg) <- lesnoms
        ug <- matrix(1, ncol(Lg), 1)
        if(Jost) 
        {###-----Jost correction-----###
            deltag <- as.matrix(apply(Lg, 2, function(x) t(x) %*% dp2 %*% x))
            X=t(Lg) %*% dp2 %*% Lg
            alpha=1/2 * (deltag %*% t(ug) + ug %*% t(deltag))
            Gam = (X + alpha)/2
            alpha = 1/(1-alpha) 		#Jost correction
            Gam = 1/(1-Gam)  			#Jost correction
            Beta_add = Gam - alpha
            Beta_mult = (Gam - alpha)/Gam
        }else
        {###-----Without Jost correction-----###
          deltag <- as.matrix(apply(Lg, 2, function(x) t(x) %*% dp2 %*% x))
          X=t(Lg) %*% dp2 %*% Lg
          alpha=1/2 * (deltag %*% t(ug) + ug %*% t(deltag))
          Gam = (X + alpha)/2
          Beta_add = Gam - alpha
          Beta_mult = (Gam - alpha)/Gam
        }
        colnames(Beta_add) <- lesnoms
        rownames(Beta_add) <- lesnoms
        return(list(Beta_add = as.dist(Beta_add), Beta_mult = as.dist(Beta_mult),
          Gamma=as.dist(Gam), Alpha=as.dist(alpha), Ng = Ng, Pg = Pg))
}# end of function Structutil

#	-------------------------------------------------- #
#					  function Diss					   #
#	-------------------------------------------------- #
Diss <- function(dis, nbhaplotypes, samples, structures, Jost) {
        structutil <- list(0)
        structutil[[1]] <- Structutil(dp2 = dis, Np = samples, NULL, Jost)
        diss <- list(structutil[[1]]$Alpha, structutil[[1]]$Gamma, structutil[[1]]$Beta_add, structutil[[1]]$Beta_mult)
         if (!is.null(structures)) {
            for (i in 1:length(structures)) {
                structutil[[i + 1]] <- Structutil(as.matrix(structutil[[1]]$Beta_add), 
                	structutil[[1]]$Ng, structures[, i], Jost)
            }## end of for i
            diss <- c(diss, tapply(1:length(structures), factor(1:length(structures)), 
                function(x) as.dist(structutil[[x + 1]]$Beta_add)))
        }## end of if    
        return(diss)
}# end of function Diss

    nbhaplotypes <- sum(samples)
    diss <- Diss(dis, nbhaplotypes, samples, structures, Jost)
    if (!is.null(structures)) {
        names(diss) <- c("Alpha", "Gamma", "Beta_add", "Beta_prop", "Beta_region")
        return(diss)
    }
	names(diss) <- c("Alpha", "Gamma", "Beta_add", "Beta_prop")
	return(diss)
}## end of function disc

######################################################################
#	----------------------------------------------------------------- #
#	  			Calculate diversity partitioning			 		  #
#	----------------------------------------------------------------- #
###################################################################### 

Jost=TRUE # set the Jost transformation as a default in this function

TD<-PFD<-NULL
#	----------------------------------------------------------------- #
#			    			Taxonomic diversity			 			  #
#	----------------------------------------------------------------- #

# define a maatrix with dissimilarity = 1
MDU.distance <- matrix(1, nrow(community.composition), nrow(community.composition)) - diag(rep(1, nrow(community.composition)))

#Call the Qdecomp function for alpha, gamma and beta estimations
	 temp_qdec<- Qdecomp(MDU.distance,t(community.composition), w=local.community.ab.weight)   
	 TD$Richness_per_plot = temp_qdec$Richness_per_plot
	 TD$Relative_abundance = temp_qdec$Relative_abundance
	 TD$Pi = temp_qdec$Pi
	 TD$Wc = temp_qdec$Wc

#	Do diversity partitioning  
	if(Jost){
    TD$Mean_Alpha = 1/(1-temp_qdec$Mean_alpha)
    TD$Alpha = 1/(1-temp_qdec$Alpha)
    TD$Gamma = 1/(1-temp_qdec$Gamma)
    TD$Beta_add = (TD$Gamma -TD$Mean_Alpha )
    TD$Beta_prop = TD$Beta_add/TD$Gamma
    #Call the disc function for alpha, gamma and beta estimations for each pair of samples
    TD$Pairwise_samples<- disc(as.data.frame(community.composition), as.dist(MDU.distance), Jost=Jost)
    }else{
    TD$Mean_Alpha = temp_qdec$Mean_alpha
    TD$Alpha = temp_qdec$Alpha
    TD$Gamma = temp_qdec$Gamma
    TD$Beta_add = (TD$Gamma -TD$Mean_Alpha )
    TD$Beta_prop = TD$Beta_add/TD$Gamma
    #	Call the disc function for alpha, gamma and beta estimations for each pair of samples
    TD$Pairwise_samples <- disc(as.data.frame(community.composition), as.dist(MDU.distance), Jost=Jost)
  }## end of taxonomic diversity


#	----------------------------------------------------------------- #
#			   Phylogenetic or functional diversity			 		  #
#	----------------------------------------------------------------- #


# Define MDU.distance depending on the phylo or functional dist
# -------------------------------------------------------------
MDU.distance <- NULL
# if dist = phylo dist
if( ! is.null( phylo.distance )){ MDU.distance <- phylo.distance }
# if dist = functional dist
if( ! is.null( funct.distance )){ MDU.distance <- funct.distance }


  if(!is.null(MDU.distance)){
#	Check if we use a distance matrix or a tree
	if( !is.matrix(MDU.distance) )
	{
		# 	Check if this is a tree object
	  	if (class(MDU.distance) != "dist") { 		
			#	Check if the tree is ultrametric	
	  		if (!is.ultrametric(MDU.distance)) { stop("Phylogeny must be ultrametric") }
		}
		#	Transform the phylogenetic tree into a phylogenetic distance matrix	
		if(class(MDU.distance) == "phylo"){ 
		MDU.distance =  as.dist(cophenetic.phylo(MDU.distance)) }
			
		#	Check if the species are the same in the "communities" and the "MDU.distance" object	
		tipnames = attributes(MDU.distance)$Labels
	}else
	 {	tipnames = colnames(MDU.distance) }
	
#	Check if the species are the same in the "communities" and the "MDU.distance" object
		comnames = row.names(community.composition)
	if( identical(sort(tipnames), sort(comnames)) == FALSE ){
		goodsp = is.element(tipnames,comnames)
		dmat = as.matrix(MDU.distance)
		MDU.distance = as.dist(dmat[goodsp,goodsp])
	}
MDU.distance = as.dist(MDU.distance)
 

#	Do diversity partitioning
   if(Jost){
		#Make sure the distance are between 0 and 1 for the Jost correction
      if(max(MDU.distance)>1) MDU.distance <- MDU.distance/max(MDU.distance)   
		#Call the Qdecomp function for alpha, gamma and beta estimations
      temp_qdec<- Qdecomp(MDU.distance,t(community.composition), w=local.community.ab.weight)   
      PFD$Alpha = 1/(1-temp_qdec$Alpha)
	  PFD$Mean_Alpha = 1/(1-temp_qdec$Mean_alpha)
      PFD$Gamma = 1/(1-temp_qdec$Gamma)
      PFD$Beta_add = (PFD$Gamma -PFD$Mean_Alpha )
      PFD$Beta_prop = (1-(PFD$Mean_Alpha / PFD$Gamma))
		#Call the disc function for alpha, gamma and beta estimations for each pair of samples
      PFD$Pairwise_samples<- disc(as.data.frame(community.composition), as.dist(MDU.distance), Jost=Jost)
    }else {
		#Call the Qdecomp function for alpha, gamma and beta estimations.
      temp_qdec<- Qdecomp(MDU.distance,t(community.composition), w=local.community.ab.weight)  
      PFD$Mean_Alpha = temp_qdec$Mean_alpha
      PFD$Alpha = temp_qdec$Alpha
      PFD$Gamma = temp_qdec$Gamma
      PFD$Beta_add = (PFD$Gamma - PFD$Mean_Alpha )
		PFD$Beta_prop = (1-(PFD$Mean_Alpha / PFD$Gamma))
		#Call the disc function for alpha, gamma and beta estimations for each pair of samples
      PFD$Pairwise_samples <- disc(as.data.frame(community.composition), as.dist(MDU.distance), Jost=Jost)
    }  
}# End of phylogenetic diversity 

######################################################################
#	----------------------------------------------------------------- #
#			    			Export function results			 		  #
#	----------------------------------------------------------------- #
###################################################################### 
out <- list(TD, PFD)
names(out) <- c("TD", "PFD") 
if( ! is.null( phylo.distance )){ names(out) <- c("TD", "PD") }
if( ! is.null( funct.distance )){ names(out) <- c("TD", "FD") }
outres <- list()

	if(outputlike == "tables")
	{
		cnom = c("Q.MeanAlpha", "Q.Gamma", "Q.Beta" ,"Q.Beta.st")
		Global.relative.abundances = out$TD$Pi
	sp.rel.ab=cbind(t(out$TD$Relative_abundance),Global.relative.abundances)
		Community.Richness = out$TD$Richness_per_plot
		Local.Weight = out$TD$Wc
		Q.Alpha = out$TD$Alpha
		Q.Alpha.Phylogeny = rep(NA,length(Q.Alpha))
	local.div=rbind(Community.Richness, Local.Weight, Q.Alpha,Q.Alpha.Phylogeny)
	div.part = matrix(NA,2,4)
		row.names(div.part) = c("No Phylogeny","With Phylogeny")
		colnames(div.part) = c("Q.Gamma","Q.MeanAlpha",  "Q.Beta" ,"Q.Beta.st")
		div.part[1,] = cbind(out$TD$Gamma,out$TD$Mean_Alpha,out$TD$Beta_add,out$TD$Beta_prop)
		comname = names(out$TD$Richness_per_plot)
		comb = as.vector(unlist(lapply(combn(comname,2,simplify=FALSE),function(x){	paste(x[1],x[2],sep="-")})))
		pairw = matrix(NA,length(comb),4)
		colnames(pairw) = c("Q.Gamma","Q.MeanAlpha", "Q.Beta" ,"Q.Beta.st")
		row.names(pairw) = comb
	PW.TD = pairw
		PW.TD[,"Q.Gamma"] = as.vector(out$TD$Pairwise_samples$Gamma)
		PW.TD[,"Q.MeanAlpha"] = as.vector(out$TD$Pairwise_samples$Alpha)
		PW.TD[,"Q.Beta"] = as.vector(out$TD$Pairwise_samples$Beta_add)
		PW.TD[,"Q.Beta.st"] = as.vector(out$TD$Pairwise_samples$Beta_prop)
	Richness.Partition = data.frame(Gamma= sum(apply(community.composition,1,sum) != 0), MeanAlpha= mean(Community.Richness), Beta= sum(apply(community.composition,1,sum) != 0)-mean(Community.Richness),Beta.st= (sum(apply(community.composition,1,sum) != 0)-mean(Community.Richness))/sum(apply(community.composition,1,sum) != 0),row.names=" ")
	
	outres$TD = list(sp.rel.ab,local.div,Richness.Partition,div.part,PW.TD)
	names(outres$TD) = c("Microbial.Units.relative.abundances","Local.diversity","Richness.Partition" , "Rao.Diversity.partition","Pairwise.partition")

	if(! is.null( phylo.distance ))
	{	
		div.part[2,] = cbind(out$PD$Gamma,out$PD$Mean_Alpha,out$PD$Beta_add,out$PD$Beta_prop)
		Q.Alpha = out$PD$Alpha
		local.div=rbind(Community.Richness, Local.Weight, Q.Alpha,Q.Alpha.Phylogeny)
	PW.PD = pairw
		PW.PD[,"Q.Gamma"] = as.vector(out$PD$Pairwise_samples$Gamma)
		PW.PD[,"Q.MeanAlpha"] = as.vector(out$PD$Pairwise_samples$Alpha)
		PW.PD[,"Q.Beta"] = as.vector(out$PD$Pairwise_samples$Beta_add)
		PW.PD[,"Q.Beta.st"] = as.vector(out$PD$Pairwise_samples$Beta_prop)
	outres$PD = list(sp.rel.ab,local.div,Richness.Partition,div.part,PW.TD,PW.PD)
	names(outres$PD) = c("Microbial.Units.relative.abundances","Local.diversity","Richness.partition"  , "Rao.diversity.partition","Pairwise.partition","Pairwise.partition.Phylogeny")
	}
	if( ! is.null( funct.distance ))
	{	
		div.part[2,] = cbind(out$FD$Gamma,out$FD$Mean_Alpha,out$FD$Beta_add,out$FD$Beta_prop)
		row.names(div.part) = c("No Functional diss","With Functional diss")		
		Q.Alpha = out$PFD$Alpha
		local.div=rbind(Community.Richness, Local.Weight, Q.Alpha,Q.Alpha.Phylogeny)
	PW.FD = pairw
		PW.FD[,"Q.Gamma"] = as.vector(out$FD$Pairwise_samples$Gamma)
		PW.FD[,"Q.MeanAlpha"] = as.vector(out$FD$Pairwise_samples$Alpha)
		PW.FD[,"Q.Beta"] = as.vector(out$FD$Pairwise_samples$Beta_add)
		PW.FD[,"Q.Beta.st"] = as.vector(out$FD$Pairwise_samples$Beta_prop)
	outres$FD = list(sp.rel.ab,local.div,Richness.Partition,div.part,PW.TD,PW.FD)
	names(outres$FD) = c("Microbial.Units.relative.abundances","Local.diversity","Richness.partition"  , "Rao.diversity.partition","Pairwise.partition","Pairwise.partition.Functional")
	}			
}else{
	outres$Rao.partition$Richness.per.community <- TD$Richness_per_plot
	outres$Rao.partition$Microbial.Units.relative.abundance <- t(TD$Relative_abundance)
	outres$Rao.partition$Global.relative.abundances <- TD$Pi
	outres$Rao.partition$Local.community.weight <- TD$Wc
	outres$Rao.partition$Q.Alpha<-TD$Alpha
	outres$Rao.partition$Q.MeanAlpha<-TD$Mean_Alpha
	outres$Rao.partition$Q.Gamma<-TD$Gamma
	outres$Rao.partition$Q.Beta<-TD$Beta_add
	outres$Rao.partition$Q.Beta.st<-TD$Beta_prop
	outres$Rao.partition$Pairwise.community$Q.MeanAlpha<-TD$Pairwise_sample$Mean_Alpha
	outres$Rao.partition$Pairwise.community$Q.Gamma<-TD$Pairwise_sample$Gamma
	outres$Rao.partition$Pairwise.community$Q.Beta<-TD$Pairwise_sample$Beta_add
	outres$Rao.partition$Pairwise.community$Q.Beta.st<-TD$Pairwise_sample$Beta_prop
	if(! is.null( phylo.distance ))
	{
		outres$Rao.partition.Phylogeny$Q.Alpha<-PFD$Alpha
		outres$Rao.partition.Phylogeny$Q.MeanAlpha<-PFD$Mean_Alpha
		outres$Rao.partition.Phylogeny$Q.Gamma<-PFD$Gamma
		outres$Rao.partition.Phylogeny$Q.Beta<-PFD$Beta_add
		outres$Rao.partition.Phylogeny$Q.Beta.st<-PFD$Beta_prop
		outres$Rao.partition.Phylogeny$Pairwise.community$Q.MeanAlpha<-PFD$Pairwise_sample$Mean_Alpha
		outres$Rao.partition.Phylogeny$Pairwise.community$Q.Gamma<-PFD$Pairwise_sample$Gamma
		outres$Rao.partition.Phylogeny$Pairwise.community$Q.Beta<-PFD$Pairwise_sample$Beta_add
		outres$Rao.partition.Phylogeny$Pairwise.community$Q.Beta.st<-PFD$Pairwise_sample$Beta_prop
		names(outres) <- c("Rao.partition","Rao.partition.Phylogeny")
	}
	if(! is.null( funct.distance ))
	{	
		outres$Rao.partition.Functional$Q.Alpha<-PFD$Alpha
		outres$Rao.partition.Functional$Q.MeanAlpha<-PFD$Mean_Alpha
		outres$Rao.partition.Functional$Q.Gamma<-PFD$Gamma
		outres$Rao.partition.Functional$Q.Beta<-PFD$Beta_add
		outres$Rao.partition.Functional$Q.Beta.st<-PFD$Beta_prop
		outres$Rao.partition.Functional$Pairwise.community$Q.MeanAlpha<-PFD$Pairwise_sample$Mean_Alpha
		outres$Rao.partition.Functional$Pairwise.community$Q.Gamma<-PFD$Pairwise_sample$Gamma
		outres$Rao.partition.Functional$Pairwise.community$Q.Beta<-PFD$Pairwise_sample$Beta_add
		outres$Rao.partition.Functional$Pairwise.community$Q.Beta.st<-PFD$Pairwise_sample$Beta_prop	
		names(outres) <- c("Rao.partition","Rao.partition.Functional")		
	}
}

return(outres)
}## end of Rao function



